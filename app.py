import streamlit as st
import pandas as pd
from io import BytesIO

# Imports pour Google Search Console
import searchconsole
from apiclient import discovery
from google_auth_oauthlib.flow import Flow

# Import pour OpenAI
import openai

###############################################################################
# Configuration de la page Streamlit
###############################################################################

st.set_page_config(
    layout="centered",
    page_title="GSC Scorecard",
    page_icon="üîåüìù"
)

###############################################################################
# Constantes
###############################################################################

ROW_CAP = 25000  # Limite de lignes pour les requ√™tes GSC
TOP_N_KEYWORDS = 50  # Nombre de mots-cl√©s √† afficher

###############################################################################
# Fonctions auxiliaires
###############################################################################

def get_search_console_data(webproperty, search_type, selected_days, dimension, nested_dimension, nested_dimension_2):
    """
    R√©cup√®re les donn√©es de la Google Search Console en fonction des param√®tres sp√©cifi√©s.
    """
    q = webproperty.query.search_type(search_type).range("today", days=selected_days).dimension(dimension)

    if nested_dimension != "none":
        q = q.dimension(nested_dimension)
    if nested_dimension_2 != "none":
        q = q.dimension(nested_dimension_2)

    q = q.limit(ROW_CAP)
    report = q.get().to_dataframe()
    return report

def categorize_with_openai(keyword, candidate_labels):
    """
    Cat√©gorise un mot-cl√© en utilisant l'API OpenAI.
    """
    prompt = (
        f"√âtant donn√© les cat√©gories suivantes, classez le mot-cl√© suivant dans la cat√©gorie appropri√©e "
        f"en fonction de son sens :\n\nMot-cl√© : {keyword}\nCat√©gories :\n- " +
        "\n- ".join(candidate_labels) +
        "\n\nFournissez uniquement la cat√©gorie, sans autre texte."
    )
    try:
        response = openai.ChatCompletion.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": "Vous √™tes un assistant utile."},
                {"role": "user", "content": prompt},
            ],
            temperature=0
        )
        # Extraire la r√©ponse
        content = response.choices[0].message.content.strip()
        return content
    except Exception as e:
        st.error(f"Erreur lors de la cat√©gorisation du mot-cl√© '{keyword}' : {e}")
        return None

@st.cache_data
def convert_df_to_excel(df):
    """
    Convertit un DataFrame en fichier Excel pour le t√©l√©chargement.
    """
    output = BytesIO()
    with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
        df.to_excel(writer, index=False)
    processed_data = output.getvalue()
    return processed_data

###############################################################################
# Application principale
###############################################################################

st.title("GSC Scorecard")

# R√©cup√©ration des identifiants GSC depuis les secrets de Streamlit
client_secret = st.secrets["installed"]["client_secret"]
client_id = st.secrets["installed"]["client_id"]
redirect_uri = st.secrets["installed"]["redirect_uris"][0]

###############################################################################
# Initialisation de l'√©tat de session pour les jetons OAuth
###############################################################################

if "gsc_token_input" not in st.session_state:
    st.session_state["gsc_token_input"] = ""
if "gsc_token_received" not in st.session_state:
    st.session_state["gsc_token_received"] = False
if "credentials_fetched" not in st.session_state:
    st.session_state["credentials_fetched"] = None
if "account" not in st.session_state:
    st.session_state["account"] = None
if "site_urls" not in st.session_state:
    st.session_state["site_urls"] = []

# Instructions pour la r√©cup√©ration du code OAuth
with st.sidebar:
    st.markdown(
        f"""
        ### √âtapes pour vous connecter √† la Google Search Console :

        1. [Connectez-vous √† GSC](https://accounts.google.com/o/oauth2/auth?response_type=code&client_id={client_id}&redirect_uri={redirect_uri}&scope=https://www.googleapis.com/auth/webmasters.readonly&access_type=offline&prompt=consent)
        2. Copiez le code d'autorisation obtenu.
        3. Collez-le ci-dessous et appuyez sur Entr√©e.
        """
    )

    # Entr√©e manuelle du code d'autorisation OAuth
    auth_code_input = st.text_input("Entrez le code OAuth de Google", value="", key="auth_code")

    if auth_code_input:
        st.session_state["gsc_token_input"] = auth_code_input
        st.session_state["gsc_token_received"] = True
        st.success("Code d'autorisation re√ßu.")

###############################################################################
# Gestion de l'authentification et r√©cup√©ration des donn√©es GSC
###############################################################################

if st.session_state.gsc_token_received:
    if not st.session_state["credentials_fetched"]:
        try:
            # Configuration du flux OAuth
            flow = Flow.from_client_config(
                {
                    "installed": {
                        "client_id": client_id,
                        "client_secret": client_secret,
                        "redirect_uris": [redirect_uri],
                        "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                        "token_uri": "https://accounts.google.com/o/oauth2/token",
                    }
                },
                scopes=["https://www.googleapis.com/auth/webmasters.readonly"],
                redirect_uri=redirect_uri,
            )
            # √âchange du code d'autorisation contre les jetons
            flow.fetch_token(code=st.session_state.gsc_token_input)
            st.session_state["credentials_fetched"] = flow.credentials

            # Construction du service Google Search Console
            service = discovery.build(
                serviceName="webmasters",
                version="v3",
                credentials=st.session_state["credentials_fetched"],
                cache_discovery=False,
            )

            # Cr√©ation de l'objet de compte Search Console
            st.session_state["account"] = searchconsole.account.Account(service, st.session_state["credentials_fetched"])

            # R√©cup√©ration de la liste des sites
            site_list = service.sites().list().execute()
            first_value = list(site_list.values())[0]
            st.session_state["site_urls"] = [dicts.get("siteUrl") for dicts in first_value if dicts.get("siteUrl")]

            st.sidebar.info("‚úîÔ∏è Identifiants GSC valides !")
            st.success("Autorisation r√©ussie.")

        except Exception as e:
            st.error(f"Une erreur est survenue lors de la r√©cup√©ration des jetons : {str(e)}")
    else:
        # Cr√©dentiels d√©j√† obtenus, aucune action n√©cessaire
        pass

    # V√©rification que les cr√©dentiels sont disponibles
    if st.session_state["credentials_fetched"]:
        # Formulaire pour la r√©cup√©ration des donn√©es
        with st.form(key="gsc_data_form"):
            # S√©lection de la propri√©t√© Web
            selected_site = st.selectbox("S√©lectionnez la propri√©t√© Web", st.session_state["site_urls"])

            # D√©finition des dimensions
            col1, col2, col3 = st.columns(3)

            with col1:
                dimension = st.selectbox(
                    "Dimension principale",
                    ("query", "page", "date", "country", "device", "searchAppearance"),
                    help="Dimension principale pour la requ√™te.",
                )
            with col2:
                nested_dimension = st.selectbox(
                    "Dimension imbriqu√©e",
                    ("none", "page", "date", "device", "searchAppearance", "country"),
                    help="Choisissez une dimension imbriqu√©e.",
                )
            with col3:
                nested_dimension_2 = st.selectbox(
                    "Seconde dimension imbriqu√©e",
                    ("none", "page", "date", "device", "searchAppearance", "country"),
                    help="Choisissez une seconde dimension imbriqu√©e.",
                )

            # Type de recherche
            search_type = st.selectbox(
                "Type de recherche",
                ("web", "news", "video", "googleNews", "image"),
                help="Sp√©cifiez le type de recherche.",
            )

            # P√©riode de temps
            timescale = st.selectbox(
                "Plage de dates",
                ("Derniers 7 jours", "Derniers 30 jours", "Derniers 3 mois", "Derniers 6 mois", "Derniers 12 mois"),
                index=1,
                help="Sp√©cifiez la plage de dates.",
            )

            # Mapping de la p√©riode de temps en jours
            timescale_mapping = {
                "Derniers 7 jours": -7,
                "Derniers 30 jours": -30,
                "Derniers 3 mois": -91,
                "Derniers 6 mois": -182,
                "Derniers 12 mois": -365,
            }

            selected_days = timescale_mapping.get(timescale, -30)

            # Bouton pour soumettre et r√©cup√©rer les donn√©es GSC
            submit_gsc_data = st.form_submit_button(label="Fetch GSC Data")

            if submit_gsc_data:
                try:
                    # Acc√®s √† la propri√©t√© Web s√©lectionn√©e
                    webproperty = st.session_state["account"][selected_site]

                    # R√©cup√©ration des donn√©es GSC
                    df = get_search_console_data(
                        webproperty,
                        search_type,
                        selected_days,
                        dimension,
                        nested_dimension,
                        nested_dimension_2,
                    )

                    # V√©rification si les donn√©es sont disponibles
                    if df.empty:
                        st.warning("üö® Aucune donn√©e disponible. Veuillez affiner vos crit√®res de recherche.")
                    else:
                        st.success(f"‚úÖ Donn√©es r√©cup√©r√©es avec succ√®s ! Nombre total de lignes : {len(df)}")

                        # S√©lection de la m√©trique pour les mots-cl√©s principaux
                        metric = st.selectbox(
                            "S√©lectionnez la m√©trique pour les mots-cl√©s principaux",
                            options=["clicks", "impressions", "ctr", "position"],
                            help="M√©trique pour la s√©lection des mots-cl√©s principaux.",
                        )

                        # Extraction des mots-cl√©s principaux
                        if 'query' in df.columns:
                            top_keywords_df = (
                                df.groupby('query')[metric]
                                .sum()
                                .reset_index()
                                .sort_values(by=metric, ascending=False)
                                .head(TOP_N_KEYWORDS)
                            )
                            top_keywords = top_keywords_df['query'].tolist()
                            st.write(f"### Top {TOP_N_KEYWORDS} mots-cl√©s bas√©s sur {metric.capitalize()}")
                            st.dataframe(top_keywords_df)
                        else:
                            st.warning("üö® La dimension 'query' n'est pas pr√©sente dans les donn√©es.")
                except Exception as e:
                    st.error(f"Une erreur est survenue lors de la r√©cup√©ration des donn√©es : {str(e)}")
else:
    st.warning("Veuillez compl√©ter le processus d'autorisation pour continuer.")
